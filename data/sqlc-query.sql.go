// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sqlc-query.sql

package data

import (
	"context"
	"database/sql"
)

const createEvent = `-- name: CreateEvent :execresult
INSERT INTO events (
    name, promo_url, location_id, repeating, start, end, menu_id
) VALUES(
    ?, ?, ?, ?, NOW(), NOW(), ?
)
`

type CreateEventParams struct {
	Name       string
	PromoUrl   sql.NullString
	LocationID sql.NullInt32
	Repeating  sql.NullString
	MenuID     sql.NullInt32
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEvent,
		arg.Name,
		arg.PromoUrl,
		arg.LocationID,
		arg.Repeating,
		arg.MenuID,
	)
}

const createLocation = `-- name: CreateLocation :execresult
INSERT INTO locations (
    name, longitude, latitude
) VALUES(
    ?, ?, ?
)
`

type CreateLocationParams struct {
	Name      string
	Longitude sql.NullString
	Latitude  sql.NullString
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createLocation, arg.Name, arg.Longitude, arg.Latitude)
}

const createPatron = `-- name: CreatePatron :execresult
INSERT INTO patrons (
    name, email, news_opt_in
) VALUES(
    ?, ?, ?
)
`

type CreatePatronParams struct {
	Name      sql.NullString
	Email     string
	NewsOptIn sql.NullBool
}

func (q *Queries) CreatePatron(ctx context.Context, arg CreatePatronParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPatron, arg.Name, arg.Email, arg.NewsOptIn)
}

const createTrucker = `-- name: CreateTrucker :execresult
INSERT INTO truckers (
    name, job, pay_rate, social_media
) VALUES(
    ?, ?, ?, ?
)
`

type CreateTruckerParams struct {
	Name        sql.NullString
	Job         sql.NullString
	PayRate     sql.NullFloat64
	SocialMedia string
}

func (q *Queries) CreateTrucker(ctx context.Context, arg CreateTruckerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTrucker,
		arg.Name,
		arg.Job,
		arg.PayRate,
		arg.SocialMedia,
	)
}

const listCashiers = `-- name: ListCashiers :many
SELECT   cashier_name, COUNT(cashier_name) AS items_count
FROM     orders_view
GROUP BY 1
ORDER BY 2 DESC
`

type ListCashiersRow struct {
	CashierName sql.NullString
	ItemsCount  int64
}

func (q *Queries) ListCashiers(ctx context.Context) ([]ListCashiersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCashiers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCashiersRow
	for rows.Next() {
		var i ListCashiersRow
		if err := rows.Scan(&i.CashierName, &i.ItemsCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailing = `-- name: ListMailing :many
SELECT   name, email
FROM     patrons_view
WHERE    news_opt_in = TRUE
`

type ListMailingRow struct {
	Name  sql.NullString
	Email string
}

func (q *Queries) ListMailing(ctx context.Context) ([]ListMailingRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMailingRow
	for rows.Next() {
		var i ListMailingRow
		if err := rows.Scan(&i.Name, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenus = `-- name: ListMenus :many
SELECT   menu, menu_item, recipe, cost
FROM     menus_view
`

func (q *Queries) ListMenus(ctx context.Context) ([]MenusView, error) {
	rows, err := q.db.QueryContext(ctx, listMenus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenusView
	for rows.Next() {
		var i MenusView
		if err := rows.Scan(
			&i.Menu,
			&i.MenuItem,
			&i.Recipe,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT   order_id, quantity, price, order_date, menu_item, patron_name, cashier_name, location_name, longitude, latitude
FROM     orders_view
`

func (q *Queries) ListOrders(ctx context.Context) ([]OrdersView, error) {
	rows, err := q.db.QueryContext(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersView
	for rows.Next() {
		var i OrdersView
		if err := rows.Scan(
			&i.OrderID,
			&i.Quantity,
			&i.Price,
			&i.OrderDate,
			&i.MenuItem,
			&i.PatronName,
			&i.CashierName,
			&i.LocationName,
			&i.Longitude,
			&i.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPopular = `-- name: ListPopular :many
SELECT   location_name, longitude, latitude, COUNT(location_name) AS items_count
FROM     orders_view
GROUP BY 1, 2, 3
ORDER BY 3 DESC
`

type ListPopularRow struct {
	LocationName string
	Longitude    sql.NullString
	Latitude     sql.NullString
	ItemsCount   int64
}

func (q *Queries) ListPopular(ctx context.Context) ([]ListPopularRow, error) {
	rows, err := q.db.QueryContext(ctx, listPopular)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPopularRow
	for rows.Next() {
		var i ListPopularRow
		if err := rows.Scan(
			&i.LocationName,
			&i.Longitude,
			&i.Latitude,
			&i.ItemsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWeekly = `-- name: ListWeekly :many
SELECT   event, promo_url, menu, location, longitude, latitude
FROM     events_view
WHERE    repeating = 'weekly' AND end > SYSDATE()
`

type ListWeeklyRow struct {
	Event     string
	PromoUrl  sql.NullString
	Menu      sql.NullString
	Location  string
	Longitude sql.NullString
	Latitude  sql.NullString
}

func (q *Queries) ListWeekly(ctx context.Context) ([]ListWeeklyRow, error) {
	rows, err := q.db.QueryContext(ctx, listWeekly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWeeklyRow
	for rows.Next() {
		var i ListWeeklyRow
		if err := rows.Scan(
			&i.Event,
			&i.PromoUrl,
			&i.Menu,
			&i.Location,
			&i.Longitude,
			&i.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const menuItem = `-- name: MenuItem :one
SELECT   id, name, recipe, cost, menu_id
FROM     menu_item
WHERE    id = ? LIMIT 1
`

func (q *Queries) MenuItem(ctx context.Context, id int32) (MenuItem, error) {
	row := q.db.QueryRowContext(ctx, menuItem, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Recipe,
		&i.Cost,
		&i.MenuID,
	)
	return i, err
}

const patron = `-- name: Patron :one
SELECT   id, name, email, news_opt_in
FROM     patrons
WHERE    id = ? LIMIT 1
`

func (q *Queries) Patron(ctx context.Context, id int32) (Patron, error) {
	row := q.db.QueryRowContext(ctx, patron, id)
	var i Patron
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.NewsOptIn,
	)
	return i, err
}

const sellerItem = `-- name: SellerItem :many
SELECT   menu_item, COUNT(menu_item) AS items_count
FROM     orders_view
GROUP BY 1
ORDER BY 2 DESC
`

type SellerItemRow struct {
	MenuItem   string
	ItemsCount int64
}

func (q *Queries) SellerItem(ctx context.Context) ([]SellerItemRow, error) {
	rows, err := q.db.QueryContext(ctx, sellerItem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SellerItemRow
	for rows.Next() {
		var i SellerItemRow
		if err := rows.Scan(&i.MenuItem, &i.ItemsCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
